JS предоставляет огромный набор довольно гибких возможностей для работы с функциями.
Так, функции можно передавать в другие функции, использовать как объекты и т.д.

В этой теме рассмотрим, как перенаправлять вызовы между функциями и как их декорировать.

- Прозрачное кеширование:
Пускай у нас есть функция slow(x). Она выполняет ресурсоёмкие вычисления, но возвращает стабильные результаты.
Другими словами, для одного и того же x функция возвращает один и тот же результат.

Если функция выполняется часто - мы можем захотеть запоминать возвращаемые ей результаты - "кэшировать" их.

Вместо того, чтобы усложнять функцию slow(x) мы можем обернуть её в функцию-обёртку "wrapper", которая добавит нам функцию кэширования.
В таком подходе масса преимуществ.

Пример:
function slow(x) { 
    /* #здесь какие-то ресурсоёмкие вычисления# */
    alert(`Called with ${x}`);
    return x;
  }
  
  function cachingDecorator(func) {
    let cache = new Map();
  
    return function(x) {
      if (cache.has(x)) {    //# Кеш содержит такой x?,
        return cache.get(x); //# Тогда читаем из него результат
      }
  
      let result = func(x); //# иначе вызываем функцию
  
      cache.set(x, result); //# и кешируем результат
      return result;
    };
  }
  
  slow = cachingDecorator(slow);

alert( slow(1) ); //# Вызываем slow(1) и кешируем результат
alert( "Again: " + slow(1) ); //# возвращаем из кеша
alert( slow(2) ); //# Вызываем slow(2) и кешируем результат
alert( "Again: " + slow(2) ); //# возвращаем из кеша

В коде выше cachingDecorator - это специальная функция - декоратор.
Она принимает другую функцию и изменяет её поведение.

Идея следующая:
мы можем вызвать cachingDecoratorс любой функцией. В результате мы получим кеширующую обёртку.
Это удобно - ведь у нас может быть множество функций, использующих кэширование.

К тому же это оставляет код в чистоте, т.к. функция кэширования отделена от основного кода.

Результат вызова cachingDecorator(func) является обёрткой: функция function(x) оборачивает вызов func(x) в кэширующую логику.

Так, с точки зрения внешнего кода функция slow(x) по прежнему выполняет то же самое. Обёртка лишь добавляет ей функцию кэширования.

ПРЕИМУЩЕСТВА отдельной фунции cachingDecorator:
1) функцию cachingDecorator() можно использовать повторно;
2) Логика кеширования является отдельной, таким образом не увеличивая сложность и читаемость slow(x);
3) Несколько декораторов можно объединить между собой (об этом позже).

- Применение func.call для передачи контекста
Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.

Например, в приведённом ниже коде функция worker.slow() перестаёт работать после применения к ней декоратора:

let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    //# здесь какая-нибудь страшно тяжёлая задача для процессора
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

//# А тут тот же код, что и выше:
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); //# Оригинальный метод работает

worker.slow = cachingDecorator(worker.slow);//# Делаем его кеширующим
alert( worker.slow(2) ); //# Ошибка: не удаётся прочитать свойство 'someMethod' из 'undefined'

Ошибка возникает в строке (*). 
Функция пытается получить доступ к this.someMethod, но завершается с ошибкой.

Причина в том, что в строке (**) декоратор вызывает оригинальную функцию func(x), а она получает this = undefined.

Мы бы наблюдали такую же картину, есди бы запустили код:
let func = worker.slow;
func(2);

Т.е. декоратор передаёт вызов оригинальному методу, но уже без контекста.

Исправить это можно при помощи специального метода функции func.call(context, ...args).
Он позволяет вызывать функцию явно устанавливая this.

Синтаксис:
func.call(context, arg1, arg2, ...)

Этот метод запускает функцию funcи использует первый аргумент как её контекст this, а все последующие - как её аргументы.

Проще говоря, два вызова ниже по сути делают одно и то же:
func(1,2,3) == func.call(obj, 1, 2, 3);

Оба вызывают функцию с аргументами 1, 2 и 3. Отличие одно - func.call ещё и устанавливает this = obj.

- Пример:
Вызываем функцию sayHi в контексте различных объектов:
sayHi.call(user) запускает sayHi, передавая this=user.
Следующая строка устанавливает this=admin.

//#Сама функция:
function sayHi() {
    alert(this.name);
  }
  
  let user = { name: "John" };
  let admin = { name: "Admin" };
  
//# используем 'call' для передачи различных объектов в качестве 'this':
sayHi.call( user ); // John
sayHi.call( admin ); // Admin

//# Используем call для вызова say с заданным контекством фразой:
unction say(phrase) {
    alert(this.name + ': ' + phrase);
    }
let user = { name: 'John'}; 
say.call( user, 'Hello'); //# видим John: Hello, т.к. user становится this, а Hello - первый аргумент.

//# Можем использовать call в обёртке для передачи контекста в исходную функцию:
let worker = {
    someMethod() {
      return 1;
    },
  
    slow(x) {
      alert("Called with " + x);
      return x * this.someMethod(); // (*)
    }
  };
  
  function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
      if (cache.has(x)) {
        return cache.get(x);
      }
      let result = func.call(this, x); // теперь 'this' передаётся правильно
      cache.set(x, result);
      return result;
    };
  }
  
  worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей
  
alert( worker.slow(2) ); // работает
alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)

Как передаётся this:
1) После декорации worker.slow становится обёрткой для function(x){...};
2) При выполнении worker.slow(2) обёртка получает 2 в качестве аргумента для this=worker (т.к. это объект перед точной);
3) Внутри обёртки (если результат не кэширован), func.call(this, x) передаёт текущий this(который равен worker) и текущий аргумент (=2) в оригинальную функцию.