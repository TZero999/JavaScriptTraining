Как говорилось в предыдущей теме, ECMAScript - это встраиваемый расширяемый язык программирования, который не имеет средств ввода-вывода и 
используется как основа для построения других скриптовых языков. 
ECMAScript стандартизирован в спецификации ECMA-262.

- Примитивные типы:
ECMAScript поддерживает 5 примитивных типов данных:
1) Числовой - Number;
2) Строковый - String;
3) Логический - Boolean;
4) Нулевой - Null;
5) Неопределённый - Undefined;

Числовой тип - 64-битный формат чисел с плавающей запятой. Определён стандартом IEEE 754-2008.
Единственное отличие от стандарта - се значения Not-a-Number представляются одним значением NaN.

Составной тип данных только 1:
1) Объектный - Object.

Есть ещё 7 типов данных, которые используются исключительно для хранения промежуточных этапов вычисляемых выражений и переменных:
1) Ссылочный - Reference;
2) Списочный - List;
3) Заключительный - Completion;
4) Описатель свойств - Properly Descriptor;
5) Идентификатор свойств - Properly Identifier;
6) Лексическое окружение - Lexical Environment;
7) Запись окружения - Environment Record;

- Инструкции
В ECMAScript имеется 15 различных видов инструкций:

1) Блок:                            {[<инструкции>]}
2) Объявление переменной:           var <список объявления переменных>
3) Пустая инструкция                ;
4) Выражение                        [строка до: ∉ {{, function}] инструкция
5) Условие                          if (<инструкция>) <выражение> [else <выражение>]
6) Цикл                             do <в> while <и>, while(<и>)<в>, for(<и>;<и>;<и>) <в>, for(<в> in <и>) <в>, for(<в> of <и>) <в>
7) Продолжение                      continue [<идентификатор>]
8) Прерывание                       break [<индентификатор>]
9) Возврат                          return [<инструкция>]
10) Сочетание                       with (<инструкция>) <выражение>
11) Метка                           <идентификатор>:<выражение>
12) Выбор                           switch(<инструкция>) case <инструкция>: [<выражения>][ case <инструкция>:[<выражения>] ...]
13) Генерация исключения)           throw <инструкция>
14) Блок try                        try <блок> catch (<идентификатор>) <блок>, try <блок> finally <блок>, try <блок> catch (<идентификатор>)<блок> finally <блок>
15) Отладчик                        debugger

- Инструкции, меняющие смысл при использовании перевода строки внутри:
1) Унарный постфиксный ++
2) Унарный постфиксный --
3) Продолжение continue
4) Прерывание break
5) Возврат return
6) Генерация исключения throw

- Блоки и область видимости:
Ещё одна особенность ECMAScript от С-подобных языков: блоки образуют "область видимости".
Объявленные в блоке переменные распространаются на всю функцию, содержащую блок.

- Объявление перемнных:
Переменные определяются ключевыми словами var/ let/ const. 
При объявлении переменная помещается в область видимости в зависимости от способа объявления:
var - в область видимости функции;
let и const - в область видимости блока кода.

Если переменная объявляется вне функции - она помещается в глобальную область видимости.
При создании новой переменной она приобретает значение undefined. 
Если переменная объявлена с инициализацией, инициализация происходит не в момент создания переменной, а при выполнении строки с инструкцией var:
var a = 42;
function foo() {
    alert(typeof a); //# Получим alert с undefined 
    var a = 10; //# Потому что конкретно для этой функции объявили переменную после alerta
}
foo();

При создании переменной она приобретает внутреннее свойство {DontDelete} и её невозможно удалить с помощью оператора delete.
Исключение - переменные, объявленные в контексте eval.

- Ключевые зарезервированные слова:
break;      default;    for;            new;        throw;      while;
case;       delete;     function;       return;     try;        witch.
catch;      do;         if;             switch;     typeof;
continue;   else;       in;             this;       var;
debugger;   finally;    instanceof;     throw;      void;

- Ключевые зарезервированные слова в расширениях:
class;      extends;
const;      import;
enum;       super;
export;

- Ключевые и зарезервированные слова при использовании строгого режима:
implements;     protected;
interface;      public;
let;            static;
package;        yield;
private;

- Операторы:
1) . доступ к свойству; [] доступ к свойству; () вызов функции; new создание нового объекта
2) ++ инкремент; -- декремент; - унарный минус; + унарный плюс; ^ поразрядное дополнение; ! логиечское дополнение; delete - удаление свойства;
typeof определение примитивного типа; void возврат неопределённого значения
3) * умножение; / деление; % остаток от деления; + сложение; - вычитание; + конкатенация строк
4) << сдвиг влево; >> сдвиг вправо с расширением знакового разряда; >>> сдвиг вправо с дополнением нулями
5) < меньше; <= меньше или равно; > больше; >= больше или равно; instanceof проверка типа объекта; in проверка наличия свойства
6) == проверка на равенство; != проверка на неравенство; === проверка на идентичность; !== проверка на неидентичность
7) & поразрядная конъюнкция;
8) ^ поразрядное сложение по модулю 2;
9) | поразрядная дизъюнкция;
10) && конъюнкция;
11) || дизъюнкция;
12) ?: тернарная условная операция;
13) = присваивание; *=, /=, +=, -=, <<=, >>=, >>>=, &=, ^=, |= присваивание с операцией
14) , множественное вычисление

- Арность
Арность - количество аргументов или операндов операции

Унарные: delete, void, typeof, ++, --, -, +, ^, !, new
Бинарные: ., [], (), *, /, +, -, + при конкатенации, <<, >>, >>>, <, <=, >, >=, instanceof, in, ==, !=, ===, !==, &, ^, |, &&, ||,
=, *=, /=, +=, -=, <<==, >=, >>>=, &=, ^=, |=, ,
Тернарные: ?:
Операторы без фиксированного количества операндов: ()

- Особенности операторов
ECMAScript не обладает опреатором, позволяющим проверить, относится ли свойство непосредственно к объекту или унаследовано.
Для этого есть метод hasOwnProperty(), но данный метод не является оператором, потому он может быть переписан любым другим свойством.

Оператор + - это единственный арифметический оператор в языке, который отличает строковые аргументы.
Если хотя бы один из операндов является строкой - "+" подействует как конкатенатор. Иначе будет выполнено сложение.

Есть языки, гдек void - это тип данных. В ECMAScript void - это оператор, который возвращает значение undefined.

Оператор "==" осуществляет проверку на равенство по алгоритму из 10 шагов.
В ряде случаев этот алгоритм подразумевает преобразование типов, что порой приводит к неочевидным результатам:
alert("NaN" == NaN);       // false
alert(NaN == NaN);         // false
alert(true == 1);          //# true
alert(true == 42);         // false
alert(null == 0);          // false
alert(0 == "");            //# true
alert("" == 0);            //# true
alert("false" == false);   // false
alert(false == 0);         //# true
alert(undefined == false); // false
alert(null == false);      // false
alert(undefined == null);  //# true
alert(" \t\r\n " == 0);    //# true

Поэкспериментировать можно тут: https://felix-kling.de/js-loose-comparison/

- Функции:

В ECMAScript Функции = Объекты.
Конструктор, что создаёт функции - Function().
Функции, как и любые другие объекты, могут храниться в переменных, объектах и массивах.
Так же они могут передаваться как аргументы в другие функции и могут возвращаться другими функциями.

Функции могут иметь свойства. Специфическая черта ECMAScript - функции могут быть вызваны.

- Разница в способах объявления функции:
//# Объявление функции
function sum(arg1, arg2) { return arg1 + arg2 };

//# задание функции с помощью выражения
var sum2 = function sum(arg1, arg2) { return arg1 + arg2 };

Наиболее существенной разницей между заданием функции с использованием объявления и заданием функции с помощью выражения является то,
что в первом случае создание переменной и присваивание ей в качестве значения функции осуществляются до выполнения кода
при входе в контекст исполнения.

Во втором случае переменная получает значение инициализатора при выполнении оператора присваивания.
При создании же переменной, осуществляемом при входе в контекст исполнения, она инициализируется значением undefined.

alert(sum(3, 4)); //# Получаем 7, т.к. переменная sum к моменту выполнения этой строки уже создана и в качестве значения ей присвоена функция
function sum(arg1, arg2) {
    return arg1 + arg2;
}

alert(sum2(3, 4)); //# Ошибка, т.к. переменная sum2 к моменту выполнения этой строки уже создана, но в качестве значения ей присвоено undefined
var sum2 = function(arg1, arg2) {
    return arg1 + arg2;
};

Ещё есть вариант с конструктором:
var sum3 = new Function("arg1", "arg2", "return arg1 + arg2;");
Но он менее предпочтителен, т.к. может негативно сказаться на производительности.

- Присваивание функций:

Функции = объект. Значит они относятся к ссылочному типу данных, а идентификаторы функций являются переменными, хранящими ссылку на функцию:
    var sum = function(arg1, arg2) {
    return arg1 + arg2;
    };
    alert(sum(3, 4));    // 7

    var sum2 = sum;
    alert(sum2(4, 2));   // 6

    sum = null;
alert(sum2(42, 42)); // 84