/* Задача: Перемешайте массив, важность: 3

Напишите функцию shuffle(array), которая перемешивает (переупорядочивает случайным образом) элементы массива.

Многократные прогоны через shuffle могут привести к разным последовательностям элементов. Например:

let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
Все последовательности элементов должны иметь одинаковую вероятность.
Например, [1,2,3] может быть переупорядочено как [1,2,3] или [1,3,2], или [3,1,2] и т.д., с равной вероятностью каждого случая.

*/

//let arr = [1, 2, 3];

let x = prompt("Введите последовательность цифр через запятую","1, 2, 3");
let array = [] = x.split(', ');

alert (`Перемешаем элементы: ` + shuffle(array));


function shuffle() {
randArr = array.sort(() => Math.random() - 0.5);
return randArr;
};

// Проверка количества исходов для каждого варианта:

let count = {
    '123': 0,
    '132': 0,
    '213': 0,
    '231': 0,
    '321': 0,
    '312': 0
  };

for (i = 0; i < 1e6 ; i++) {
    shuffle(array);
    count[array.join('')]++;
}

for (let key in count) {
    console.log(`${key}: ${count[key]}`);
}
// Автор утверждает, что такое перемешивание - ненадёжно и зависит от движка.
// Хромовский V8 отлично справляется и с таким кодом, выдавая в коде 
// количества получений каждого исхода ~ 166к. Это отлично, гно для других браузеров этот код лучше переписать так,
// как советует автор.

//-------------------------------------------------------------------------------------------------------------------------------------
/* Ответ автора:

Это, конечно, будет работать, потому что Math.random() - 0.5 отдаёт случайное число,
которое может быть положительным или отрицательным, следовательно, функция сортировки меняет порядок элементов случайным образом.

Но поскольку метод sort не предназначен для использования в таких случаях, не все возможные варианты имеют одинаковую вероятность.

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // случайный индекс от 0 до i

    // поменять элементы местами
    // мы используем для этого синтаксис "деструктурирующее присваивание"
    // подробнее о нём - в следующих главах
    // то же самое можно записать как:
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}

Если посмотреть с точки зрения производительности, то алгоритм «Тасование Фишера — Йетса» намного быстрее,
 так как в нём нет лишних затрат на сортировку.
 */