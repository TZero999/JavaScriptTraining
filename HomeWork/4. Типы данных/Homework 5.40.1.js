/* Задача: Хранение отметок "прочитано". Важность: 5.
 
Есть массив сообщений:

let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

У вас есть к ним доступ, но управление этим массивом происходит где-то ещё.
Добавляются новые сообщения и удаляются старые, и вы не знаете в какой момент это может произойти.

Имея такую вводную информацию, решите, какую структуру данных вы могли бы использовать для ответа на вопрос «было ли сообщение прочитано?».
Структура должна быть подходящей, чтобы можно было однозначно сказать, было ли прочитано это сообщение для каждого объекта сообщения.

P.S. Когда сообщение удаляется из массива messages, оно должно также исчезать из структуры данных.

P.P.S. Нам не следует модифицировать сами объекты сообщений, добавлять туда свойства.
Если сообщения принадлежат какому-то другому коду, то это может привести к плохим последствиям.

*/

let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"}
];

let readMessages = new WeakSet();

readMessages.add(messages[0]);
readMessages.add(messages[1]);

alert(readMessages.has(messages[0])); // true
alert(readMessages.has(messages[2])); // false

/* Даже полностью верно написал код, угадав решение автора точь в точь.

Получаем WeakSet, который хранит набор сообщений и проверяет их наличие в нём.
Очищаться он будет автоматически.
Минус всё тот же - не можем его перебрать и получить всё прочитанные сообщения одной командой.

-------------------------------------------------------------------------------------------------------------------------------
Автор предлагает ещё одну модификацию кода:

Альтернативным решением может быть добавление свойства вида message.isRead=true к сообщению после его прочтения.
Так как сообщения принадлежат чужому коду, то это не очень хорошо, но если использовать свойство-символ,
то вероятность конфликтов будет небольшой.

// символьное свойство вместо имени, которое известно только нашему коду
let isRead = Symbol("isRead");
messages[0][isRead] = true;

Теперь чужой код вряд ли увидит наше дополнительное свойство.

При этом автор утверждает, что хоть символы и позволяют уменьшить вероятность проблем,
использование здесь WeakSet лучше с архитектурной точки зрения.
*/
