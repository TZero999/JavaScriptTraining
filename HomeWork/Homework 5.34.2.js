/* Задача:

Почему 6.35.toFixed(1) == 6.3?

Методы Math.round и toFixed, согласно документации, округляют до ближайшего целого числа:
0 - 4 округляется в меньшую сторону, тогда как 5 - 9 в большую сторону.
Так:
alert( 1.35.toFixed(1) ); // 1.4

НО 
alert( 6.35.toFixed(1) ); // 6.3

Как правильно округлить до 6,35 до 6,4?

*/
let num = +prompt("Введите число, которое хотите округлить","6.35");
alert("Вот результат toFixed(1): " + num.toFixed(1) );
alert ("А вот результат Math.ceil((x * 10) / 10): " + Math.round(num*10)/10);

/* После экспериментов стало ясно, что числа, с дробной часть ".35" считаются правильно
оботит способами только до 3.35 включительно. 4.35 уже выдаёт 4.3 в первом способе. 
Продолжу экспериментировать:
3.65 - неверно.
3.55 - неверно.
3.45 - верно.
20.35 - верно.
15.45 - неверно.
15.55 - верно.
Итог - Диапазон некорректных значений от 3.45 до 15.55.
Ясное дело, что это связано с EEE-754 и с потерей точности,
но почему именно такие диапазоны?
*/

/* Объяснение автора:
Потеря точности может как увеличивать, так и уменьшать число. В данном случае число 6.35 становится чуть меньше,
поэтому оно округляется в меньшую сторону.

Для числа, например, 1.35 потеря точности приводит к увеличению числа, поэтому округление произойдёт в большую сторону.

Обратите внимание, что для числа 63.5 не происходит потери точности.
Дело в том, что десятичная часть 0.5 на самом деле 1/2. Дробные числа, делённые на степень 2, точно представлены в двоичной системе.
Ответ:
alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
*/